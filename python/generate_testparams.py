## Programmatically generate the file testparams.coffee

import os, random

basepath, folder = os.path.split(os.getcwd())
if folder == 'python':
    os.chdir(basepath) # Navigate to the root of the project unless we are already there
elif folder == 'bci_erp': # no idea if this is safe!!
    basepath = os.getcwd()
else:
    raise OSError('Python script was executed from an unknown path. Try running from (project_root)/python/')

location_paramfile = 'app/coffee/modules/home/home'

filename = 'testparams.coffee'      # Output param file
num_trials = 4     # Number of trials to run
num_pad = 2         # ensure at least num_pad low tones occur first
time_ms = 400      # Time in ms for each trial
oddball_rate = 0.25 # This is the rate at which the oddball occurs

# Tones to be used by the module
tones = ['C4', 'C5']  # lo/hi - Should only be two so we can use some hackery to do the randomness

def get_weighted_bits(p=0.5):
    # p is the probability of returning a 1
    r = random.random()
    if r < p:
        return 1
    return 0

def get_asserted_list(n, p=0.5):
    # This will produce a list with EXACTLY p percent ones in it. This is so we do not get oddballs with no tones
    k = p * n
    if not (k == int(k)):
        raise ValueError("The product p*n must be an integer value.")

    while True:
        bitlist = [get_weighted_bits(p) for dummy in range(n)]
        if sum(bitlist) == k:
            break

    return bitlist

def get_asserted_epoch_list(n, p=0.5):
    # We want an experimental setup which is random, but not TOO random
    # This ensures that we get a list with exactly p percent ones in it, AND we have one bit per each "epoch"
    # where epoch E = 1/p. This ensures that the experiment never goes more than 2E trials without a bit
    # k = number of ones
    # E = expectation value for the number of trials to get a success
    k = p * n
    E = 1 / p
    if not (k == int(k) and E == int(E)):
        raise ValueError("The 1/p and p*n must both be integer values.")
    k, E = int(k), int(E)
    while True:
        bitlist = []
        for i in range(k):
            bitlist += get_asserted_list(E, p)
        # Now we need to check to see if we have any adjacent ones
        bitlist2 = [n for n in bitlist]
        bitlist2.append(bitlist2.pop(0)) # move first to end
        sumlist = [a+b for (a,b) in zip(bitlist, bitlist2)]
        if 1 == max(sumlist):
            break
    return bitlist



coffee_header = """## testparams.coffee
## THIS FILE IS AUTOMATICALLY GENERATED!! DO NOT EDIT!!
## See generate_testparams.py for modifying this file

## This file encodes the object which will be used by the model to create the sequence of tones used in the
## Oddball EEG paradigm to elicit a P300 response.

"""

coffee_object = """
module.exports =
  timeout: {TIMEOUT_MS}
  tones: {TONES_LIST}
  toneLow: '{TONE_LOW}'
  toneHigh: '{TONE_HIGH}'
"""
tones_list = [tones[0] for dummy in range(num_pad)]
tones_list += [tones[i] for i in get_asserted_epoch_list(num_trials, oddball_rate)]
tones_list += ['C3'] # Sequence complete tone

coffee_file = coffee_header + coffee_object.format(TIMEOUT_MS=time_ms,
                                                   TONES_LIST=tones_list,
                                                   TONE_LOW=tones[0],
                                                   TONE_HIGH=tones[1])

print(coffee_file)
with open(filename, 'w') as ofile:
    ofile.write(basepath + coffee_file)